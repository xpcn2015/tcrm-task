// automatically generated by the FlatBuffers compiler, do not modify

// @generated

#![allow(clippy::extra_unused_lifetimes)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::missing_panics_doc)]
#![allow(clippy::missing_errors_doc)]
#![allow(clippy::must_use_candidate)]
#![allow(clippy::used_underscore_binding)]
#![allow(clippy::pub_underscore_fields)]
#![allow(clippy::elidable_lifetime_names)]
#![allow(clippy::doc_markdown)]

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tcrm {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod task {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_STREAM_SOURCE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_STREAM_SOURCE: i8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_STREAM_SOURCE: [StreamSource; 2] =
            [StreamSource::Stdout, StreamSource::Stderr];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct StreamSource(pub i8);
        #[allow(non_upper_case_globals)]
        impl StreamSource {
            pub const Stdout: Self = Self(0);
            pub const Stderr: Self = Self(1);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 1;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Stdout, Self::Stderr];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Stdout => Some("Stdout"),
                    Self::Stderr => Some("Stderr"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for StreamSource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for StreamSource {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for StreamSource {
            type Output = StreamSource;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for StreamSource {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for StreamSource {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for StreamSource {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_STATE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_STATE: i8 = 127;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_STATE: [TaskState; 6] = [
            TaskState::Pending,
            TaskState::Initiating,
            TaskState::Running,
            TaskState::Ready,
            TaskState::Finished,
            TaskState::Invalid,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskState(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskState {
            pub const Pending: Self = Self(0);
            pub const Initiating: Self = Self(1);
            pub const Running: Self = Self(2);
            pub const Ready: Self = Self(3);
            pub const Finished: Self = Self(4);
            pub const Invalid: Self = Self(127);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 127;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Pending,
                Self::Initiating,
                Self::Running,
                Self::Ready,
                Self::Finished,
                Self::Invalid,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Pending => Some("Pending"),
                    Self::Initiating => Some("Initiating"),
                    Self::Running => Some("Running"),
                    Self::Ready => Some("Ready"),
                    Self::Finished => Some("Finished"),
                    Self::Invalid => Some("Invalid"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskState {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskState {
            type Output = TaskState;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TaskState {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskState {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskState {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PROCESS_STATE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PROCESS_STATE: i8 = 127;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PROCESS_STATE: [ProcessState; 4] = [
            ProcessState::Stopped,
            ProcessState::Running,
            ProcessState::Pause,
            ProcessState::Invalid,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ProcessState(pub i8);
        #[allow(non_upper_case_globals)]
        impl ProcessState {
            pub const Stopped: Self = Self(0);
            pub const Running: Self = Self(1);
            pub const Pause: Self = Self(2);
            pub const Invalid: Self = Self(127);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 127;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Stopped, Self::Running, Self::Pause, Self::Invalid];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Stopped => Some("Stopped"),
                    Self::Running => Some("Running"),
                    Self::Pause => Some("Pause"),
                    Self::Invalid => Some("Invalid"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for ProcessState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for ProcessState {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for ProcessState {
            type Output = ProcessState;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for ProcessState {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for ProcessState {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for ProcessState {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PROCESS_CONTROL_ACTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PROCESS_CONTROL_ACTION: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PROCESS_CONTROL_ACTION: [ProcessControlAction; 3] = [
            ProcessControlAction::Stop,
            ProcessControlAction::Pause,
            ProcessControlAction::Resume,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ProcessControlAction(pub i8);
        #[allow(non_upper_case_globals)]
        impl ProcessControlAction {
            pub const Stop: Self = Self(0);
            pub const Pause: Self = Self(1);
            pub const Resume: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[Self::Stop, Self::Pause, Self::Resume];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Stop => Some("Stop"),
                    Self::Pause => Some("Pause"),
                    Self::Resume => Some("Resume"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for ProcessControlAction {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for ProcessControlAction {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for ProcessControlAction {
            type Output = ProcessControlAction;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for ProcessControlAction {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for ProcessControlAction {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for ProcessControlAction {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_ERROR_TYPE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_ERROR_TYPE: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_ERROR_TYPE: [TaskErrorType; 5] = [
            TaskErrorType::IO,
            TaskErrorType::Handle,
            TaskErrorType::Channel,
            TaskErrorType::InvalidConfiguration,
            TaskErrorType::Control,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskErrorType(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskErrorType {
            pub const IO: Self = Self(0);
            pub const Handle: Self = Self(1);
            pub const Channel: Self = Self(2);
            pub const InvalidConfiguration: Self = Self(3);
            pub const Control: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::IO,
                Self::Handle,
                Self::Channel,
                Self::InvalidConfiguration,
                Self::Control,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::IO => Some("IO"),
                    Self::Handle => Some("Handle"),
                    Self::Channel => Some("Channel"),
                    Self::InvalidConfiguration => Some("InvalidConfiguration"),
                    Self::Control => Some("Control"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskErrorType {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskErrorType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskErrorType {
            type Output = TaskErrorType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TaskErrorType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskErrorType {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskErrorType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_TERMINATE_REASON: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_TERMINATE_REASON: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_TERMINATE_REASON: [TaskTerminateReason; 5] = [
            TaskTerminateReason::Timeout,
            TaskTerminateReason::Cleanup,
            TaskTerminateReason::DependenciesFinished,
            TaskTerminateReason::UserRequested,
            TaskTerminateReason::InternalError,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskTerminateReason(pub i8);
        #[allow(non_upper_case_globals)]
        impl TaskTerminateReason {
            pub const Timeout: Self = Self(0);
            pub const Cleanup: Self = Self(1);
            pub const DependenciesFinished: Self = Self(2);
            pub const UserRequested: Self = Self(3);
            pub const InternalError: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Timeout,
                Self::Cleanup,
                Self::DependenciesFinished,
                Self::UserRequested,
                Self::InternalError,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Timeout => Some("Timeout"),
                    Self::Cleanup => Some("Cleanup"),
                    Self::DependenciesFinished => Some("DependenciesFinished"),
                    Self::UserRequested => Some("UserRequested"),
                    Self::InternalError => Some("InternalError"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskTerminateReason {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskTerminateReason {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskTerminateReason {
            type Output = TaskTerminateReason;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TaskTerminateReason {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskTerminateReason {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskTerminateReason {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_EVENT_STOP_REASON: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_EVENT_STOP_REASON: u8 = 7;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_EVENT_STOP_REASON: [TaskEventStopReason; 8] = [
            TaskEventStopReason::NONE,
            TaskEventStopReason::Finished,
            TaskEventStopReason::TerminatedTimeout,
            TaskEventStopReason::TerminatedCleanup,
            TaskEventStopReason::TerminatedDependenciesFinished,
            TaskEventStopReason::TerminatedUserRequested,
            TaskEventStopReason::TerminatedInternalError,
            TaskEventStopReason::Error,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskEventStopReason(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskEventStopReason {
            pub const NONE: Self = Self(0);
            pub const Finished: Self = Self(1);
            pub const TerminatedTimeout: Self = Self(2);
            pub const TerminatedCleanup: Self = Self(3);
            pub const TerminatedDependenciesFinished: Self = Self(4);
            pub const TerminatedUserRequested: Self = Self(5);
            pub const TerminatedInternalError: Self = Self(6);
            pub const Error: Self = Self(7);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 7;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Finished,
                Self::TerminatedTimeout,
                Self::TerminatedCleanup,
                Self::TerminatedDependenciesFinished,
                Self::TerminatedUserRequested,
                Self::TerminatedInternalError,
                Self::Error,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Finished => Some("Finished"),
                    Self::TerminatedTimeout => Some("TerminatedTimeout"),
                    Self::TerminatedCleanup => Some("TerminatedCleanup"),
                    Self::TerminatedDependenciesFinished => Some("TerminatedDependenciesFinished"),
                    Self::TerminatedUserRequested => Some("TerminatedUserRequested"),
                    Self::TerminatedInternalError => Some("TerminatedInternalError"),
                    Self::Error => Some("Error"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskEventStopReason {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskEventStopReason {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskEventStopReason {
            type Output = TaskEventStopReason;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TaskEventStopReason {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskEventStopReason {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskEventStopReason {}
        pub struct TaskEventStopReasonUnionTableOffset {}

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TASK_EVENT_UNION: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TASK_EVENT_UNION: u8 = 6;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TASK_EVENT_UNION: [TaskEventUnion; 7] = [
            TaskEventUnion::NONE,
            TaskEventUnion::Started,
            TaskEventUnion::Output,
            TaskEventUnion::Ready,
            TaskEventUnion::Stopped,
            TaskEventUnion::Error,
            TaskEventUnion::ProcessControl,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TaskEventUnion(pub u8);
        #[allow(non_upper_case_globals)]
        impl TaskEventUnion {
            pub const NONE: Self = Self(0);
            pub const Started: Self = Self(1);
            pub const Output: Self = Self(2);
            pub const Ready: Self = Self(3);
            pub const Stopped: Self = Self(4);
            pub const Error: Self = Self(5);
            pub const ProcessControl: Self = Self(6);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 6;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::Started,
                Self::Output,
                Self::Ready,
                Self::Stopped,
                Self::Error,
                Self::ProcessControl,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::Started => Some("Started"),
                    Self::Output => Some("Output"),
                    Self::Ready => Some("Ready"),
                    Self::Stopped => Some("Stopped"),
                    Self::Error => Some("Error"),
                    Self::ProcessControl => Some("ProcessControl"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TaskEventUnion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TaskEventUnion {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TaskEventUnion {
            type Output = TaskEventUnion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TaskEventUnion {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TaskEventUnion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TaskEventUnion {}
        pub struct TaskEventUnionUnionTableOffset {}

        pub enum TaskConfigOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskConfig<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskConfig<'a> {
            type Inner = TaskConfig<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TaskConfig<'a> {
            pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
            pub const VT_ARGS: flatbuffers::VOffsetT = 6;
            pub const VT_WORKING_DIR: flatbuffers::VOffsetT = 8;
            pub const VT_ENV: flatbuffers::VOffsetT = 10;
            pub const VT_TIMEOUT_MS: flatbuffers::VOffsetT = 12;
            pub const VT_ENABLE_STDIN: flatbuffers::VOffsetT = 14;
            pub const VT_READY_INDICATOR: flatbuffers::VOffsetT = 16;
            pub const VT_READY_INDICATOR_SOURCE: flatbuffers::VOffsetT = 18;
            pub const VT_USE_PROCESS_GROUP: flatbuffers::VOffsetT = 20;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskConfig { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskConfigArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskConfig<'bldr>> {
                let mut builder = TaskConfigBuilder::new(_fbb);
                builder.add_timeout_ms(args.timeout_ms);
                if let Some(x) = args.ready_indicator {
                    builder.add_ready_indicator(x);
                }
                if let Some(x) = args.env {
                    builder.add_env(x);
                }
                if let Some(x) = args.working_dir {
                    builder.add_working_dir(x);
                }
                if let Some(x) = args.args {
                    builder.add_args(x);
                }
                if let Some(x) = args.command {
                    builder.add_command(x);
                }
                builder.add_use_process_group(args.use_process_group);
                builder.add_ready_indicator_source(args.ready_indicator_source);
                builder.add_enable_stdin(args.enable_stdin);
                builder.finish()
            }

            #[inline]
            pub fn command(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskConfig::VT_COMMAND, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn args(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(TaskConfig::VT_ARGS, None)
                }
            }
            #[inline]
            pub fn working_dir(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskConfig::VT_WORKING_DIR, None)
                }
            }
            #[inline]
            pub fn env(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry>>,
                    >>(TaskConfig::VT_ENV, None)
                }
            }
            #[inline]
            pub fn timeout_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TaskConfig::VT_TIMEOUT_MS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn enable_stdin(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskConfig::VT_ENABLE_STDIN, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ready_indicator(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        TaskConfig::VT_READY_INDICATOR,
                        None,
                    )
                }
            }
            #[inline]
            pub fn ready_indicator_source(&self) -> StreamSource {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<StreamSource>(
                            TaskConfig::VT_READY_INDICATOR_SOURCE,
                            Some(StreamSource::Stdout),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn use_process_group(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TaskConfig::VT_USE_PROCESS_GROUP, Some(true))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskConfig<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "command",
                        Self::VT_COMMAND,
                        true,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("args", Self::VT_ARGS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "working_dir",
                        Self::VT_WORKING_DIR,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnvEntry>>,
                    >>("env", Self::VT_ENV, false)?
                    .visit_field::<u64>("timeout_ms", Self::VT_TIMEOUT_MS, false)?
                    .visit_field::<bool>("enable_stdin", Self::VT_ENABLE_STDIN, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "ready_indicator",
                        Self::VT_READY_INDICATOR,
                        false,
                    )?
                    .visit_field::<StreamSource>(
                        "ready_indicator_source",
                        Self::VT_READY_INDICATOR_SOURCE,
                        false,
                    )?
                    .visit_field::<bool>("use_process_group", Self::VT_USE_PROCESS_GROUP, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskConfigArgs<'a> {
            pub command: Option<flatbuffers::WIPOffset<&'a str>>,
            pub args: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub working_dir: Option<flatbuffers::WIPOffset<&'a str>>,
            pub env: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvEntry<'a>>>,
                >,
            >,
            pub timeout_ms: u64,
            pub enable_stdin: bool,
            pub ready_indicator: Option<flatbuffers::WIPOffset<&'a str>>,
            pub ready_indicator_source: StreamSource,
            pub use_process_group: bool,
        }
        impl<'a> Default for TaskConfigArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskConfigArgs {
                    command: None, // required field
                    args: None,
                    working_dir: None,
                    env: None,
                    timeout_ms: 0,
                    enable_stdin: false,
                    ready_indicator: None,
                    ready_indicator_source: StreamSource::Stdout,
                    use_process_group: true,
                }
            }
        }

        pub struct TaskConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskConfigBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_command(&mut self, command: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_COMMAND, command);
            }
            #[inline]
            pub fn add_args(
                &mut self,
                args: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_ARGS, args);
            }
            #[inline]
            pub fn add_working_dir(&mut self, working_dir: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskConfig::VT_WORKING_DIR,
                    working_dir,
                );
            }
            #[inline]
            pub fn add_env(
                &mut self,
                env: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<EnvEntry<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskConfig::VT_ENV, env);
            }
            #[inline]
            pub fn add_timeout_ms(&mut self, timeout_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(TaskConfig::VT_TIMEOUT_MS, timeout_ms, 0);
            }
            #[inline]
            pub fn add_enable_stdin(&mut self, enable_stdin: bool) {
                self.fbb_
                    .push_slot::<bool>(TaskConfig::VT_ENABLE_STDIN, enable_stdin, false);
            }
            #[inline]
            pub fn add_ready_indicator(
                &mut self,
                ready_indicator: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    TaskConfig::VT_READY_INDICATOR,
                    ready_indicator,
                );
            }
            #[inline]
            pub fn add_ready_indicator_source(&mut self, ready_indicator_source: StreamSource) {
                self.fbb_.push_slot::<StreamSource>(
                    TaskConfig::VT_READY_INDICATOR_SOURCE,
                    ready_indicator_source,
                    StreamSource::Stdout,
                );
            }
            #[inline]
            pub fn add_use_process_group(&mut self, use_process_group: bool) {
                self.fbb_.push_slot::<bool>(
                    TaskConfig::VT_USE_PROCESS_GROUP,
                    use_process_group,
                    true,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskConfigBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskConfigBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskConfig<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskConfig::VT_COMMAND, "command");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskConfig<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskConfig");
                ds.field("command", &self.command());
                ds.field("args", &self.args());
                ds.field("working_dir", &self.working_dir());
                ds.field("env", &self.env());
                ds.field("timeout_ms", &self.timeout_ms());
                ds.field("enable_stdin", &self.enable_stdin());
                ds.field("ready_indicator", &self.ready_indicator());
                ds.field("ready_indicator_source", &self.ready_indicator_source());
                ds.field("use_process_group", &self.use_process_group());
                ds.finish()
            }
        }
        pub enum EnvEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct EnvEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for EnvEntry<'a> {
            type Inner = EnvEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> EnvEntry<'a> {
            pub const VT_KEY: flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                EnvEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args EnvEntryArgs<'args>,
            ) -> flatbuffers::WIPOffset<EnvEntry<'bldr>> {
                let mut builder = EnvEntryBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                if let Some(x) = args.key {
                    builder.add_key(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn key(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(EnvEntry::VT_KEY, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn value(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(EnvEntry::VT_VALUE, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for EnvEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "value",
                        Self::VT_VALUE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct EnvEntryArgs<'a> {
            pub key: Option<flatbuffers::WIPOffset<&'a str>>,
            pub value: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for EnvEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                EnvEntryArgs {
                    key: None,   // required field
                    value: None, // required field
                }
            }
        }

        pub struct EnvEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvEntry::VT_KEY, key);
            }
            #[inline]
            pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvEntry::VT_VALUE, value);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> EnvEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                EnvEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<EnvEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, EnvEntry::VT_KEY, "key");
                self.fbb_.required(o, EnvEntry::VT_VALUE, "value");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for EnvEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("EnvEntry");
                ds.field("key", &self.key());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum TaskErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskError<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskError<'a> {
            type Inner = TaskError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TaskError<'a> {
            pub const VT_KIND: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskErrorArgs<'args>,
            ) -> flatbuffers::WIPOffset<TaskError<'bldr>> {
                let mut builder = TaskErrorBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_kind(args.kind);
                builder.finish()
            }

            #[inline]
            pub fn kind(&self) -> TaskErrorType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskErrorType>(TaskError::VT_KIND, Some(TaskErrorType::IO))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(TaskError::VT_MESSAGE, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TaskError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<TaskErrorType>("kind", Self::VT_KIND, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TaskErrorArgs<'a> {
            pub kind: TaskErrorType,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TaskErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                TaskErrorArgs {
                    kind: TaskErrorType::IO,
                    message: None, // required field
                }
            }
        }

        pub struct TaskErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_kind(&mut self, kind: TaskErrorType) {
                self.fbb_
                    .push_slot::<TaskErrorType>(TaskError::VT_KIND, kind, TaskErrorType::IO);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskError::VT_MESSAGE, message);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskError::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskError<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskError");
                ds.field("kind", &self.kind());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum DummyTableOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DummyTable<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DummyTable<'a> {
            type Inner = DummyTable<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DummyTable<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DummyTable { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args DummyTableArgs,
            ) -> flatbuffers::WIPOffset<DummyTable<'bldr>> {
                let mut builder = DummyTableBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for DummyTable<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct DummyTableArgs {}
        impl<'a> Default for DummyTableArgs {
            #[inline]
            fn default() -> Self {
                DummyTableArgs {}
            }
        }

        pub struct DummyTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DummyTableBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DummyTableBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DummyTableBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DummyTable<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DummyTable<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DummyTable");
                ds.finish()
            }
        }
        pub enum ErrorStopReasonOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ErrorStopReason<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ErrorStopReason<'a> {
            type Inner = ErrorStopReason<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ErrorStopReason<'a> {
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ErrorStopReason { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ErrorStopReasonArgs<'args>,
            ) -> flatbuffers::WIPOffset<ErrorStopReason<'bldr>> {
                let mut builder = ErrorStopReasonBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn message(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(
                            ErrorStopReason::VT_MESSAGE,
                            None,
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ErrorStopReason<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ErrorStopReasonArgs<'a> {
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ErrorStopReasonArgs<'a> {
            #[inline]
            fn default() -> Self {
                ErrorStopReasonArgs {
                    message: None, // required field
                }
            }
        }

        pub struct ErrorStopReasonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorStopReasonBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ErrorStopReason::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ErrorStopReasonBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ErrorStopReasonBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ErrorStopReason<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_
                    .required(o, ErrorStopReason::VT_MESSAGE, "message");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ErrorStopReason<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ErrorStopReason");
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum SystemTimeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SystemTime<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SystemTime<'a> {
            type Inner = SystemTime<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> SystemTime<'a> {
            pub const VT_NANOS_SINCE_EPOCH: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SystemTime { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SystemTimeArgs,
            ) -> flatbuffers::WIPOffset<SystemTime<'bldr>> {
                let mut builder = SystemTimeBuilder::new(_fbb);
                builder.add_nanos_since_epoch(args.nanos_since_epoch);
                builder.finish()
            }

            #[inline]
            pub fn nanos_since_epoch(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(SystemTime::VT_NANOS_SINCE_EPOCH, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SystemTime<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("nanos_since_epoch", Self::VT_NANOS_SINCE_EPOCH, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SystemTimeArgs {
            pub nanos_since_epoch: u64,
        }
        impl<'a> Default for SystemTimeArgs {
            #[inline]
            fn default() -> Self {
                SystemTimeArgs {
                    nanos_since_epoch: 0,
                }
            }
        }

        pub struct SystemTimeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SystemTimeBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_nanos_since_epoch(&mut self, nanos_since_epoch: u64) {
                self.fbb_
                    .push_slot::<u64>(SystemTime::VT_NANOS_SINCE_EPOCH, nanos_since_epoch, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SystemTimeBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SystemTimeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SystemTime<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SystemTime<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SystemTime");
                ds.field("nanos_since_epoch", &self.nanos_since_epoch());
                ds.finish()
            }
        }
        pub enum StartedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StartedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StartedEvent<'a> {
            type Inner = StartedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StartedEvent<'a> {
            pub const VT_PROCESS_ID: flatbuffers::VOffsetT = 4;
            pub const VT_CREATED_AT: flatbuffers::VOffsetT = 6;
            pub const VT_RUNNING_AT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StartedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StartedEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<StartedEvent<'bldr>> {
                let mut builder = StartedEventBuilder::new(_fbb);
                if let Some(x) = args.running_at {
                    builder.add_running_at(x);
                }
                if let Some(x) = args.created_at {
                    builder.add_created_at(x);
                }
                builder.add_process_id(args.process_id);
                builder.finish()
            }

            #[inline]
            pub fn process_id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(StartedEvent::VT_PROCESS_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn created_at(&self) -> Option<SystemTime<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<SystemTime>>(
                        StartedEvent::VT_CREATED_AT,
                        None,
                    )
                }
            }
            #[inline]
            pub fn running_at(&self) -> Option<SystemTime<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<SystemTime>>(
                        StartedEvent::VT_RUNNING_AT,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for StartedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("process_id", Self::VT_PROCESS_ID, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<SystemTime>>(
                        "created_at",
                        Self::VT_CREATED_AT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<SystemTime>>(
                        "running_at",
                        Self::VT_RUNNING_AT,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct StartedEventArgs<'a> {
            pub process_id: u32,
            pub created_at: Option<flatbuffers::WIPOffset<SystemTime<'a>>>,
            pub running_at: Option<flatbuffers::WIPOffset<SystemTime<'a>>>,
        }
        impl<'a> Default for StartedEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                StartedEventArgs {
                    process_id: 0,
                    created_at: None,
                    running_at: None,
                }
            }
        }

        pub struct StartedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_process_id(&mut self, process_id: u32) {
                self.fbb_
                    .push_slot::<u32>(StartedEvent::VT_PROCESS_ID, process_id, 0);
            }
            #[inline]
            pub fn add_created_at(&mut self, created_at: flatbuffers::WIPOffset<SystemTime<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SystemTime>>(
                        StartedEvent::VT_CREATED_AT,
                        created_at,
                    );
            }
            #[inline]
            pub fn add_running_at(&mut self, running_at: flatbuffers::WIPOffset<SystemTime<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SystemTime>>(
                        StartedEvent::VT_RUNNING_AT,
                        running_at,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StartedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StartedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StartedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StartedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StartedEvent");
                ds.field("process_id", &self.process_id());
                ds.field("created_at", &self.created_at());
                ds.field("running_at", &self.running_at());
                ds.finish()
            }
        }
        pub enum OutputEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OutputEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OutputEvent<'a> {
            type Inner = OutputEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OutputEvent<'a> {
            pub const VT_LINE: flatbuffers::VOffsetT = 4;
            pub const VT_SRC: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OutputEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OutputEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<OutputEvent<'bldr>> {
                let mut builder = OutputEventBuilder::new(_fbb);
                if let Some(x) = args.line {
                    builder.add_line(x);
                }
                builder.add_src(args.src);
                builder.finish()
            }

            #[inline]
            pub fn line(&self) -> &'a str {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(OutputEvent::VT_LINE, None)
                        .unwrap()
                }
            }
            #[inline]
            pub fn src(&self) -> StreamSource {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<StreamSource>(OutputEvent::VT_SRC, Some(StreamSource::Stdout))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for OutputEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("line", Self::VT_LINE, true)?
                    .visit_field::<StreamSource>("src", Self::VT_SRC, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OutputEventArgs<'a> {
            pub line: Option<flatbuffers::WIPOffset<&'a str>>,
            pub src: StreamSource,
        }
        impl<'a> Default for OutputEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                OutputEventArgs {
                    line: None, // required field
                    src: StreamSource::Stdout,
                }
            }
        }

        pub struct OutputEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OutputEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_line(&mut self, line: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(OutputEvent::VT_LINE, line);
            }
            #[inline]
            pub fn add_src(&mut self, src: StreamSource) {
                self.fbb_
                    .push_slot::<StreamSource>(OutputEvent::VT_SRC, src, StreamSource::Stdout);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OutputEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OutputEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OutputEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, OutputEvent::VT_LINE, "line");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OutputEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OutputEvent");
                ds.field("line", &self.line());
                ds.field("src", &self.src());
                ds.finish()
            }
        }
        pub enum ReadyEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ReadyEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ReadyEvent<'a> {
            type Inner = ReadyEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ReadyEvent<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ReadyEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args ReadyEventArgs,
            ) -> flatbuffers::WIPOffset<ReadyEvent<'bldr>> {
                let mut builder = ReadyEventBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for ReadyEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct ReadyEventArgs {}
        impl<'a> Default for ReadyEventArgs {
            #[inline]
            fn default() -> Self {
                ReadyEventArgs {}
            }
        }

        pub struct ReadyEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadyEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ReadyEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ReadyEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ReadyEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ReadyEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ReadyEvent");
                ds.finish()
            }
        }
        pub enum StoppedEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StoppedEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StoppedEvent<'a> {
            type Inner = StoppedEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StoppedEvent<'a> {
            pub const VT_EXIT_CODE: flatbuffers::VOffsetT = 4;
            pub const VT_REASON_TYPE: flatbuffers::VOffsetT = 6;
            pub const VT_REASON: flatbuffers::VOffsetT = 8;
            pub const VT_FINISHED_AT: flatbuffers::VOffsetT = 10;
            pub const VT_SIGNAL: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StoppedEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StoppedEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<StoppedEvent<'bldr>> {
                let mut builder = StoppedEventBuilder::new(_fbb);
                builder.add_signal(args.signal);
                if let Some(x) = args.finished_at {
                    builder.add_finished_at(x);
                }
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                builder.add_exit_code(args.exit_code);
                builder.add_reason_type(args.reason_type);
                builder.finish()
            }

            #[inline]
            pub fn exit_code(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(StoppedEvent::VT_EXIT_CODE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason_type(&self) -> TaskEventStopReason {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskEventStopReason>(
                            StoppedEvent::VT_REASON_TYPE,
                            Some(TaskEventStopReason::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            StoppedEvent::VT_REASON,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn finished_at(&self) -> Option<SystemTime<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<SystemTime>>(
                        StoppedEvent::VT_FINISHED_AT,
                        None,
                    )
                }
            }
            #[inline]
            pub fn signal(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(StoppedEvent::VT_SIGNAL, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_finished(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::Finished {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_timeout(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedTimeout {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_cleanup(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedCleanup {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_dependencies_finished(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedDependenciesFinished {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_user_requested(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedUserRequested {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_terminated_internal_error(&self) -> Option<DummyTable<'a>> {
                if self.reason_type() == TaskEventStopReason::TerminatedInternalError {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { DummyTable::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn reason_as_error(&self) -> Option<ErrorStopReason<'a>> {
                if self.reason_type() == TaskEventStopReason::Error {
                    let u = self.reason();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ErrorStopReason::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for StoppedEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_field::<i32>("exit_code", Self::VT_EXIT_CODE, false)?
     .visit_union::<TaskEventStopReason, _>("reason_type", Self::VT_REASON_TYPE, "reason", Self::VT_REASON, true, |key, v, pos| {
        match key {
          TaskEventStopReason::Finished => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::Finished", pos),
          TaskEventStopReason::TerminatedTimeout => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::TerminatedTimeout", pos),
          TaskEventStopReason::TerminatedCleanup => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::TerminatedCleanup", pos),
          TaskEventStopReason::TerminatedDependenciesFinished => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::TerminatedDependenciesFinished", pos),
          TaskEventStopReason::TerminatedUserRequested => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::TerminatedUserRequested", pos),
          TaskEventStopReason::TerminatedInternalError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DummyTable>>("TaskEventStopReason::TerminatedInternalError", pos),
          TaskEventStopReason::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorStopReason>>("TaskEventStopReason::Error", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<SystemTime>>("finished_at", Self::VT_FINISHED_AT, false)?
     .visit_field::<i32>("signal", Self::VT_SIGNAL, false)?
     .finish();
                Ok(())
            }
        }
        pub struct StoppedEventArgs<'a> {
            pub exit_code: i32,
            pub reason_type: TaskEventStopReason,
            pub reason: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
            pub finished_at: Option<flatbuffers::WIPOffset<SystemTime<'a>>>,
            pub signal: i32,
        }
        impl<'a> Default for StoppedEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                StoppedEventArgs {
                    exit_code: 0,
                    reason_type: TaskEventStopReason::NONE,
                    reason: None, // required field
                    finished_at: None,
                    signal: 0,
                }
            }
        }

        pub struct StoppedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StoppedEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_exit_code(&mut self, exit_code: i32) {
                self.fbb_
                    .push_slot::<i32>(StoppedEvent::VT_EXIT_CODE, exit_code, 0);
            }
            #[inline]
            pub fn add_reason_type(&mut self, reason_type: TaskEventStopReason) {
                self.fbb_.push_slot::<TaskEventStopReason>(
                    StoppedEvent::VT_REASON_TYPE,
                    reason_type,
                    TaskEventStopReason::NONE,
                );
            }
            #[inline]
            pub fn add_reason(
                &mut self,
                reason: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(StoppedEvent::VT_REASON, reason);
            }
            #[inline]
            pub fn add_finished_at(&mut self, finished_at: flatbuffers::WIPOffset<SystemTime<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<SystemTime>>(
                        StoppedEvent::VT_FINISHED_AT,
                        finished_at,
                    );
            }
            #[inline]
            pub fn add_signal(&mut self, signal: i32) {
                self.fbb_
                    .push_slot::<i32>(StoppedEvent::VT_SIGNAL, signal, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StoppedEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StoppedEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StoppedEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, StoppedEvent::VT_REASON, "reason");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StoppedEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StoppedEvent");
                ds.field("exit_code", &self.exit_code());
                ds.field("reason_type", &self.reason_type());
                match self.reason_type() {
                    TaskEventStopReason::Finished => {
                        if let Some(x) = self.reason_as_finished() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedTimeout => {
                        if let Some(x) = self.reason_as_terminated_timeout() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedCleanup => {
                        if let Some(x) = self.reason_as_terminated_cleanup() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedDependenciesFinished => {
                        if let Some(x) = self.reason_as_terminated_dependencies_finished() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedUserRequested => {
                        if let Some(x) = self.reason_as_terminated_user_requested() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::TerminatedInternalError => {
                        if let Some(x) = self.reason_as_terminated_internal_error() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventStopReason::Error => {
                        if let Some(x) = self.reason_as_error() {
                            ds.field("reason", &x)
                        } else {
                            ds.field(
                                "reason",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("reason", &x)
                    }
                };
                ds.field("finished_at", &self.finished_at());
                ds.field("signal", &self.signal());
                ds.finish()
            }
        }
        pub enum ErrorEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ErrorEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ErrorEvent<'a> {
            type Inner = ErrorEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ErrorEvent<'a> {
            pub const VT_ERROR: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ErrorEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ErrorEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<ErrorEvent<'bldr>> {
                let mut builder = ErrorEventBuilder::new(_fbb);
                if let Some(x) = args.error {
                    builder.add_error(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn error(&self) -> TaskError<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TaskError>>(ErrorEvent::VT_ERROR, None)
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ErrorEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TaskError>>(
                        "error",
                        Self::VT_ERROR,
                        true,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ErrorEventArgs<'a> {
            pub error: Option<flatbuffers::WIPOffset<TaskError<'a>>>,
        }
        impl<'a> Default for ErrorEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                ErrorEventArgs {
                    error: None, // required field
                }
            }
        }

        pub struct ErrorEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_error(&mut self, error: flatbuffers::WIPOffset<TaskError<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TaskError>>(
                        ErrorEvent::VT_ERROR,
                        error,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ErrorEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ErrorEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ErrorEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, ErrorEvent::VT_ERROR, "error");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ErrorEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ErrorEvent");
                ds.field("error", &self.error());
                ds.finish()
            }
        }
        pub enum ProcessControlEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ProcessControlEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ProcessControlEvent<'a> {
            type Inner = ProcessControlEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ProcessControlEvent<'a> {
            pub const VT_ACTION: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ProcessControlEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ProcessControlEventArgs,
            ) -> flatbuffers::WIPOffset<ProcessControlEvent<'bldr>> {
                let mut builder = ProcessControlEventBuilder::new(_fbb);
                builder.add_action(args.action);
                builder.finish()
            }

            #[inline]
            pub fn action(&self) -> ProcessControlAction {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ProcessControlAction>(
                            ProcessControlEvent::VT_ACTION,
                            Some(ProcessControlAction::Stop),
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ProcessControlEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<ProcessControlAction>("action", Self::VT_ACTION, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ProcessControlEventArgs {
            pub action: ProcessControlAction,
        }
        impl<'a> Default for ProcessControlEventArgs {
            #[inline]
            fn default() -> Self {
                ProcessControlEventArgs {
                    action: ProcessControlAction::Stop,
                }
            }
        }

        pub struct ProcessControlEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProcessControlEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_action(&mut self, action: ProcessControlAction) {
                self.fbb_.push_slot::<ProcessControlAction>(
                    ProcessControlEvent::VT_ACTION,
                    action,
                    ProcessControlAction::Stop,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ProcessControlEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ProcessControlEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ProcessControlEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ProcessControlEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ProcessControlEvent");
                ds.field("action", &self.action());
                ds.finish()
            }
        }
        pub enum TaskEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TaskEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TaskEvent<'a> {
            type Inner = TaskEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TaskEvent<'a> {
            pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_EVENT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TaskEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TaskEventArgs,
            ) -> flatbuffers::WIPOffset<TaskEvent<'bldr>> {
                let mut builder = TaskEventBuilder::new(_fbb);
                if let Some(x) = args.event {
                    builder.add_event(x);
                }
                builder.add_event_type(args.event_type);
                builder.finish()
            }

            #[inline]
            pub fn event_type(&self) -> TaskEventUnion {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TaskEventUnion>(TaskEvent::VT_EVENT_TYPE, Some(TaskEventUnion::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn event(&self) -> flatbuffers::Table<'a> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            TaskEvent::VT_EVENT,
                            None,
                        )
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_started(&self) -> Option<StartedEvent<'a>> {
                if self.event_type() == TaskEventUnion::Started {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { StartedEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_output(&self) -> Option<OutputEvent<'a>> {
                if self.event_type() == TaskEventUnion::Output {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { OutputEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_ready(&self) -> Option<ReadyEvent<'a>> {
                if self.event_type() == TaskEventUnion::Ready {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ReadyEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_stopped(&self) -> Option<StoppedEvent<'a>> {
                if self.event_type() == TaskEventUnion::Stopped {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { StoppedEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_error(&self) -> Option<ErrorEvent<'a>> {
                if self.event_type() == TaskEventUnion::Error {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ErrorEvent::init_from_table(u) })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn event_as_process_control(&self) -> Option<ProcessControlEvent<'a>> {
                if self.event_type() == TaskEventUnion::ProcessControl {
                    let u = self.event();
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    Some(unsafe { ProcessControlEvent::init_from_table(u) })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for TaskEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<TaskEventUnion, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, true, |key, v, pos| {
        match key {
          TaskEventUnion::Started => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartedEvent>>("TaskEventUnion::Started", pos),
          TaskEventUnion::Output => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OutputEvent>>("TaskEventUnion::Output", pos),
          TaskEventUnion::Ready => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadyEvent>>("TaskEventUnion::Ready", pos),
          TaskEventUnion::Stopped => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StoppedEvent>>("TaskEventUnion::Stopped", pos),
          TaskEventUnion::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ErrorEvent>>("TaskEventUnion::Error", pos),
          TaskEventUnion::ProcessControl => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ProcessControlEvent>>("TaskEventUnion::ProcessControl", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct TaskEventArgs {
            pub event_type: TaskEventUnion,
            pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for TaskEventArgs {
            #[inline]
            fn default() -> Self {
                TaskEventArgs {
                    event_type: TaskEventUnion::NONE,
                    event: None, // required field
                }
            }
        }

        pub struct TaskEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TaskEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_event_type(&mut self, event_type: TaskEventUnion) {
                self.fbb_.push_slot::<TaskEventUnion>(
                    TaskEvent::VT_EVENT_TYPE,
                    event_type,
                    TaskEventUnion::NONE,
                );
            }
            #[inline]
            pub fn add_event(
                &mut self,
                event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskEvent::VT_EVENT, event);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TaskEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TaskEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TaskEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                self.fbb_.required(o, TaskEvent::VT_EVENT, "event");
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TaskEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TaskEvent");
                ds.field("event_type", &self.event_type());
                match self.event_type() {
                    TaskEventUnion::Started => {
                        if let Some(x) = self.event_as_started() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventUnion::Output => {
                        if let Some(x) = self.event_as_output() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventUnion::Ready => {
                        if let Some(x) = self.event_as_ready() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventUnion::Stopped => {
                        if let Some(x) = self.event_as_stopped() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventUnion::Error => {
                        if let Some(x) = self.event_as_error() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    TaskEventUnion::ProcessControl => {
                        if let Some(x) = self.event_as_process_control() {
                            ds.field("event", &x)
                        } else {
                            ds.field(
                                "event",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("event", &x)
                    }
                };
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `TaskEvent`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_unchecked`.
        pub fn root_as_task_event(buf: &[u8]) -> Result<TaskEvent, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<TaskEvent>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `TaskEvent` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_task_event_unchecked`.
        pub fn size_prefixed_root_as_task_event(
            buf: &[u8],
        ) -> Result<TaskEvent, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<TaskEvent>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `TaskEvent` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_unchecked`.
        pub fn root_as_task_event_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TaskEvent<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<TaskEvent<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `TaskEvent` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_task_event_unchecked`.
        pub fn size_prefixed_root_as_task_event_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<TaskEvent<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<TaskEvent<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a TaskEvent and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `TaskEvent`.
        pub unsafe fn root_as_task_event_unchecked(buf: &[u8]) -> TaskEvent {
            flatbuffers::root_unchecked::<TaskEvent>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed TaskEvent and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `TaskEvent`.
        pub unsafe fn size_prefixed_root_as_task_event_unchecked(buf: &[u8]) -> TaskEvent {
            flatbuffers::size_prefixed_root_unchecked::<TaskEvent>(buf)
        }
        #[inline]
        pub fn finish_task_event_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TaskEvent<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_task_event_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<TaskEvent<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod Task
} // pub mod TCRM
